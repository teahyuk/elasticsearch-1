# 엘라스틱서치 실무가이드

## 09 엘라스틱서치와 루씬 이야기
- 클러스터 관점에서 구성요소 살펴보기
- 엘라스틱서치 샤드 VS. 루씬 인덱스
- 엘라스틱서치가 근실시간(Near Real-Time) 검색을 제공하는 이유
- 고가용성을 위한 Translog의 비밀
- 엘라스틱서치 샤드 최적화

---
### 클러스터 관점에서 구성요소 살펴보기

#### 클러스터
- 데이터를 실제로 가지고 있는 노드의 모음
- 같은 클러스터 내부의 데이터만 서로 공유가능
    - Cross Cluster Serarch 제공
        - 다수의 클러스터 검색 기능
        - 과거 Tribe Node 형태로 제공했으나 deprecated

#### 노드
- 실행된 엘라스틱서치 인스턴스
- 노드는 내부에 다수의 인덱스를 가지고 있으며, 각 인덱스는 다수의 문서를 가지고 있다.

#### 인덱스
- 인덱스는 유사한 특성을 가지고 있는 문서들을 모아둔 컬렉션

#### 문서
- 검색 대상이 되는 실제 물리적인 데이터
- JSON 형식으로 표현

#### 샤드
- 물리적인 한계를 뛰어넘기 위해 샤드(Shard)라는 개념을 도입
- 데이터를 분산 저장하는 방식으로 손쉬운 수평 확장이 가능

#### 레플리카
- 샤드의 복제본
- 검색시 레플리카를 이용하면 읽기 분산에 유리

#### 세그먼트
- 루씬에 데이터가 색인되면 데이터는 최소한의 단위인 토큰으로 분리되고 특수한 형태의 자료구조(세그먼트)로 저장
- 세그먼트는 읽기에 최적화된 자료구조로서 역색인이라는 특수한 형태로 변환되어 물리적인 디스크에 저장

---
### 엘라스틱서치 샤드 VS. 루씬 인덱스
- 실제 데이터를 가지고 있는 최소 단위의 검색 모듈 == 샤드
- 엘라스틱서치 샤드는 하나의 루씬 인덱스
- 하나의 샤드는 자체적으로 데이터를 색인하고 검색할 수 있는 가장 작은 크기의 단일 검색엔진

| Elasticsearch | Index |||
|-|-|-|-|
| Elastic Shard || Elastic Shard ||
| Lucene Index || Lucene Index ||
| Segment | Segment | Segment | Segment | 

---
### 엘라스틱서치가 근실시간(Near Real-Time) 검색을 제공하는 이유
- 다양한 데이터의 색인이 가능하고 근실시간 검색을 제공하는 것을 목표로 개발
- 샤드 == "장애 복구 기능을 가진 작은 루씬 기반의 단일 검색 서버"

#### 색인 작업 시 세그먼트의 기본 동작 방식
- 루씬은 백그라운드에서 주기적으로 세그먼트 파일을 병합(Merge)하는 작업을 수행
    - 모든 세그먼트들을 물리적으로 하나의 파일로 병합
- 루씬은 색인 작업 시 기존에 생성된 세그먼트에는 정보를 추가하거나 수정하지 않는다.

#### 세그먼트 불변성
- 루씬에서 수정을 허용하지 않는 세그먼트의 이러한 동작방식을 불변성(Immutablity)라고 부른다.
    - 동시성 문제를 회피: Lock이 필요없음
    - 시스템 캐시를 적극적으로 활용할 수 있다: 일정시간동안 캐시를 유지시킬 수 있다
    - 높은 캐시 적중률을 유지 할 수 있다: 캐시의 수명이 길어진다
    - 리소스를 절감할 수 있다
- 다수의 세그먼트를 생성해서 제공하는 방식
    - 변경이 일어날 때마다 추가로 세그먼트를 생성
    - 검색 요청 시에는 생성된 모든 세그먼트를 읽어서 검색 결과 제공

#### 세그먼트 불변성과 업데이트
- 문서 하나를 삭제하려면 전체 역색인 구조를 뒤져서 관련된 텀을 모두 제거해야하기 때문에 세그먼트를 새로 생성하는 것과 차이가 없다.
- 즉시 삭제하는 것이 아니라 주기적으로 세그먼트가 재생성되는 Merge 작업을 기다렸다가 물리적인 삭제 처리를 함께 진행

#### 루씬을 위한 Flush, Commit, Merge
- 루씬은 효율적인 색인 작업을 위해 내부적으로 일정 크기의 버퍼(In-memory Buffer)를 가지고 있다.
- 색인 요청이 많을 경우 매번 세그먼트를 만드는 것이 아니라 버퍼에 Queue로 쌓아두었다가 한번에 처리
- fsync 방식의 디스크 동기화 대신 write 방식을 이용해 쓰기 과정을 수행
- 인메모리 버퍼 기반의 처리 과정을 루씬에서는 Flush라고 한다.
    - 디스크에 물리적으로 기록되는 것을 100% 보장하지 않는다.

##### 루씬 Flush
- 세그먼트가 생성된 후 검색이 가능해지도록 수행하는 작업
- write() 함수로 동기화가 수행되기 때문에 커널 시스템 캐시에만 데이터가 생성
- 물리적으로 디스크에 쓰여진 상태는 아님

##### 루씬 Commit
- 커널 시스템 캐시 내용을 물리적인 디스크로 쓰는 작업

##### 루씬 Merge
- 다수의 세그먼트를 하나로 통합하는 과정

#### 엘라스틱서치를 위한 Refresh, Flush, Optimize API

| 루씬 | 엘라스틱서치 |
|-|-|
| Flush | Refresh |
| Commit | Flush |
| Merge | Optimize API |

##### 엘라스틱서치 Refresh
- 실시간 검색에 가깝게 동작하기 위해 주기적으로 인메모리 버퍼에 대해 Flush 작업 수행
- 모든 샤드에서 1초에 한 번씩 수행
- "인덱스를 새로고침한다"는 의미

##### 엘라스틱서치 Flush
- 루씬의 Commit 작업을 수행하고, 새로운 Translog를 수행한다.
    - Translog는 샤드의 장애 복구를 위해 제공되는 특수한 파일
- 5초에 한 번씩 수행

##### 엘라스틱서치 Optimize API
- forced merge API라고도 함
- 루씬 merge를 강제로 수행하는 기능

---
### 고가용성을 위한 Translog의 비밀
- 분산 시스템이 지원해야하는 고가용성을 제공하기 위해 내부적으로 Translog라는 특수한 형태의 파일을 유지/관리

#### Translog의 동작 순서
1. 데이터가 추가되면 Translog에 기록되고 동시에 인메모리 버퍼에 추가
2. Refresh가 수행되면 인메모리 버퍼에서는 사라지지만 Translog에는 계속 남아있다.
3. 더 많은 데이터가 추가되고 지속적으로 세그먼트가 추가
4. Translog가 일정 크기 이상으로 커지면 Flush 작업이 수행
5. 커밋 포인트가 디스크에 Flush 된다.
6. 시스템 캐시 내용이 디스크에 Flush 된다.
7. 디스크 동기화에 성공하면 누적되어 있던 Translog 기록이 삭제된다.

---
### 엘라스틱서치 샤드 최적화

#### 운영 중에 샤드의 개수를 수정하지 못하는 이유
- 엘라스틱서치의 샤드는 루씬 인덱스의 확장
- 루씬의 입장에서는 엘라스틱서치 인덱스를 구성하는 전체 데이터가 별도로 존재하고, 자신은 그 중 일부만 가지고 있다는 점을 알 수 없음
- 샤드의 개수를 조정한다는 의미는 각각의 독립적인 루씬의 데이터를 모두 재조정한다는 의미
    - 세그먼트를 쪼개서 전송하고, 모아서 다시 합치는 작업이 필요하나 세그먼트 불변성에 위배되어 불가능
- 새로운 인덱스를 생성하고 재색인해야한다.

#### 레플리카 샤드의 복제본 수는 얼마가 적당할까?
- 레플리카 샤드의 복제본 수는 운영중에도 얼마든지 변경 가능
- 전체적인 색인 성능이 떨어질 수 있다.
    - 프라이머리 샤드와 레플리카 샤드 모두 동일한 세그먼트 과정을 거치게 되어 있다.

#### 클러스터에서 운영 가능한 최대 샤드 수는?
- 개별 인덱스를 생설할 때 설정 가능한 샤드 수는 1024개
- 샤드 1개가 물리적으로 50GB를 넘지 않도록 권장

#### 하나의 인덱스에 생성 가능한 최대 문서 수는?
- 루씬 내부 세그먼트에 색인 가능한 최대 문서 수를 다음과 같이 정의
```
    Integer.MAX_VALUE - 128
    2,147,483,519 (약20억개)
```
- 하나의 샤드에 약20억개 문서 색인가능 x 인덱스는 1024개 샤드 생성가능
    - 대략 2조개의 문서

---
## 10 대용량 처리를 위한 시스템 최적화
- 노드 실행환경과 JVM 옵션
- 힙 크기를 32GB 이하로 유지해야하는 이유
- 엘라스틱서치와 가상 메모리
- 분산환경에서의 메모리 스와핑
- 시스템 튜닝 포인트

### 노드 실행환경과 JVM 옵션
- 엘라스틱서치의 버전에 따라 내부에서 사용하고 있는 루씬의 버전도 함께 달라진다.
- 64Bit 아키텍쳐를 사용하기 위해 자바8 이상을 사용 권장
- 전체적인 성능 향상을 위해 다수의 JVM 옵션을 반드시 튜닝
    - 엘라스틱서치에서 기본적으로 제공하는 옵션을 가급적 그대로 사용 권장

### 힙 크기를 32GB 이하로 유지해야하는 이유
- 기본 힙 크기 1GB는 테스트를 위한 용도
- 최대 힙 크기를 32GB로 제한하는 것은 모든 자바 어플리케이션에 동일하게 해당
    - Ordinary Object Pointer (OOP)
        - 32Bit OOP - 4GB 메모리 공간을 가리킬 수 있다.
        - 64Bit OOP - 18EB 메모리 공간을 가리킬 수 있다.
        - 32Bit Compressed OOP - 4GB의 객체를 가리킬 수 있다. 
            - 객체 최소단위 8비트, 32GB의 메모리 공간을 가리킬 수 있다.
- JVM에 30GB 정도 할당하면 Zero-Based Compressed OOP 사용 가능

### 엘라스틱서치와 가상 메모리
- 루씬은 내부적으로 자바에서 제공하는 NIO(New Input/Output) 기술을 활용
- JVM의 힙과 시스템의 힙을 함께 사용
    - 엘라스틱서치에서 루씬이 원활하게 동작하기 위해서 가상 메모리 설정중 mmap 크기 항목 수정

### 분산환경에서의 메모리 스와핑
- 메모리를 많이 사용하는 엘라스틱서치의 특성상 스와핑 작업이 발생할 경우 안정성에 치명적
- 시스템 환경에 따라 적절한 스와핑 제한
    - 시스템을 엘라스틱서치 노드 전용으로 사용하는 경우: 스와핑 완전 비활성화
    - 시스템 특성상 완전 비활성화가 불가능한 경우
        - 스와핑 주기 조절
        - 애플리케이션 레벨의 제한: memory_lock

### 시스템 튜닝 포인트
- 엘라스틱서치가 단독으로 사용되는 경우에 ulimit, sysctl 명령어를 통해서 리소스를 최대한 독점해서 사용할 수 있도록 설정
    - Max Open File (File I/O)
    - Max Thread
    - Network WAS

---
# ElasticSearch Cookbook 3rd 
- [Sample.KR](http://www.acornpub.co.kr/book/elasticsearch-cookbook-3)
- [Sample.US](https://github.com/PacktPublishing/Elasticsearch-5x-Cookbook-Third-Edition)

## 10 클러스터와 노드 관리
- API를 통한 클러스터 헬스 제어
- API를 통한 클러스터 상태 제어
- API를 통한 클러스터 노드 정보 얻기
- API를 통한 노드 통계 얻기
- 작업 관리 API 사용
- 핫 스레드 API
- 샤드 할당 관리
- 세그먼트 API로 세그먼트 모니터링
- 캐시 정리
